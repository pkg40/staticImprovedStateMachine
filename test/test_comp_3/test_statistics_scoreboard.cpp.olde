#ifdef ARDUINO
#include <Arduino.h>
#endif
#include <unity.h>
#include "../src/improvedStateMachine.hpp"

// Include the implementation for proper linking
#include "../src/improvedStateMachine.cpp"

// Test instance
ImprovedStateMachine* sm = nullptr;

void setUp() {
#ifdef ARDUINO
    if (!Serial) {
        Serial.begin(115200);
        while (!Serial) {
            delay(100);
        }
        delay(1000);
    }
#endif
    delete sm;
    sm = new ImprovedStateMachine();
}

void tearDown() {
    delete sm;
    sm = nullptr;
}

// =============================================================================
// STATISTICS AND SCOREBOARD TESTS (25 tests)
// =============================================================================

void test_051_statistics_tracking() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    stateMachineStats initialStats = sm->getStatistics();
    sm->processEvent(1);
    stateMachineStats afterStats = sm->getStatistics();
    
    TEST_ASSERT_EQUAL_UINT32(initialStats.totalTransitions + 1, afterStats.totalTransitions);
    TEST_ASSERT_EQUAL_UINT32(initialStats.stateChanges + 1, afterStats.stateChanges);
}

void test_052_failed_transition_statistics() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    stateMachineStats initialStats = sm->getStatistics();
    sm->processEvent(99); // No matching transition
    stateMachineStats afterStats = sm->getStatistics();
    
    TEST_ASSERT_EQUAL_UINT32(initialStats.failedTransitions + 1, afterStats.failedTransitions);
}

void test_053_action_execution_stats() {
    sm->setInitialState(1);
    stateTransition t(1, 1, 2);
    sm->addTransition(t);
    
    stateMachineStats before = sm->getStatistics();
    sm->processEvent(1);
    stateMachineStats after = sm->getStatistics();
    
    TEST_ASSERT_TRUE(after.actionExecutions >= before.actionExecutions);
}

void test_054_statistics_accumulation() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    stateMachineStats initial = sm->getStatistics();
    
    // Process multiple events
    for (int i = 0; i < 10; i++) {
        if (sm->getCurrentStateId() == 1) {
            sm->processEvent(1);
        } else {
            sm->processEvent(2);
        }
    }
    
    stateMachineStats final = sm->getStatistics();
    
    TEST_ASSERT_EQUAL_UINT32(initial.totalTransitions + 10, final.totalTransitions);
    TEST_ASSERT_EQUAL_UINT32(initial.stateChanges + 10, final.stateChanges);
}

void test_055_scoreboard_functionality() {
    sm->setInitialState(1);
    sm->setScoreboard(100, 1);
    sm->setScoreboard(200, 2);
    
    TEST_ASSERT_EQUAL_UINT32(100, sm->getScoreboard(1));
    TEST_ASSERT_EQUAL_UINT32(200, sm->getScoreboard(2));
}

void test_056_scoreboard_updates() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    uint32_t initialScore = sm->getScoreboard(1);
    sm->processEvent(1); // Should increment scoreboard for state 1
    uint32_t afterScore = sm->getScoreboard(1);
    
    TEST_ASSERT_TRUE(afterScore > initialScore);
}

void test_057_scoreboard_boundaries() {
    sm->setScoreboard(0xFFFFFFFF, 0);
    sm->setScoreboard(0, 1);
    
    TEST_ASSERT_EQUAL_UINT32(0xFFFFFFFF, sm->getScoreboard(0));
    TEST_ASSERT_EQUAL_UINT32(0, sm->getScoreboard(1));
}

void test_058_multi_state_scoreboard() {
    sm->setInitialState(0);
    
    // Set up multiple states and scoreboards
    for (uint8_t i = 0; i < 5; i++) {
        sm->setScoreboard(i * 10, i);
    }
    
    // Verify all scoreboards
    for (uint8_t i = 0; i < 5; i++) {
        TEST_ASSERT_EQUAL_UINT32(i * 10, sm->getScoreboard(i));
    }
}

void test_059_scoreboard_overflow_protection() {
    sm->setScoreboard(0xFFFFFFFE, 0);
    sm->setInitialState(0);
    sm->addTransition(stateTransition(0, 1, 1));
    
    // This should increment scoreboard but not overflow
    sm->processEvent(1);
    
    uint32_t score = sm->getScoreboard(0);
    TEST_ASSERT_TRUE(score >= 0xFFFFFFFE); // Should handle near-overflow
}

void test_060_performance_timing() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    uint32_t start = micros();
    for (int i = 0; i < 100; i++) {
        if (sm->getCurrentStateId() == 1) {
            sm->processEvent(1);
        } else {
            sm->processEvent(2);
        }
    }
    uint32_t elapsed = micros() - start;
    
    // Should complete 100 transitions in reasonable time
    TEST_ASSERT_TRUE(elapsed < 100000); // Less than 100ms
}

void test_061_statistics_consistency() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    // Process known number of events
    for (int i = 0; i < 20; i++) {
        if (sm->getCurrentStateId() == 1) {
            sm->processEvent(1);
        } else {
            sm->processEvent(2);
        }
    }
    
    stateMachineStats stats = sm->getStatistics();
    
    // Verify statistics consistency
    TEST_ASSERT_TRUE(stats.stateChanges <= stats.totalTransitions);
    TEST_ASSERT_TRUE(stats.actionExecutions <= stats.totalTransitions);
}

void test_062_scoreboard_state_correlation() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 3));
    sm->addTransition(stateTransition(3, 3, 1));
    
    uint32_t score1_before = sm->getScoreboard(1);
    uint32_t score2_before = sm->getScoreboard(2);
    uint32_t score3_before = sm->getScoreboard(3);
    
    // Cycle through states
    sm->processEvent(1); // 1->2, should increment score for state 1
    sm->processEvent(2); // 2->3, should increment score for state 2
    sm->processEvent(3); // 3->1, should increment score for state 3
    
    uint32_t score1_after = sm->getScoreboard(1);
    uint32_t score2_after = sm->getScoreboard(2);
    uint32_t score3_after = sm->getScoreboard(3);
    
    TEST_ASSERT_TRUE(score1_after > score1_before);
    TEST_ASSERT_TRUE(score2_after > score2_before);
    TEST_ASSERT_TRUE(score3_after > score3_before);
}

void test_063_statistics_error_tracking() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    stateMachineStats before = sm->getStatistics();
    
    // Valid event
    sm->processEvent(1);
    
    // Invalid events
    sm->processEvent(99);
    sm->processEvent(88);
    sm->processEvent(77);
    
    stateMachineStats after = sm->getStatistics();
    
    TEST_ASSERT_EQUAL_UINT32(before.totalTransitions + 4, after.totalTransitions);
    TEST_ASSERT_EQUAL_UINT32(before.stateChanges + 1, after.stateChanges);
    TEST_ASSERT_EQUAL_UINT32(before.failedTransitions + 3, after.failedTransitions);
}

void test_064_scoreboard_persistence() {
    sm->setInitialState(1);
    sm->setScoreboard(1000, 1);
    sm->setScoreboard(2000, 2);
    
    // Add transitions and process events
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    sm->processEvent(1); // 1->2
    sm->processEvent(2); // 2->1
    
    // Scoreboards should persist and increment
    TEST_ASSERT_TRUE(sm->getScoreboard(1) > 1000);
    TEST_ASSERT_TRUE(sm->getScoreboard(2) > 2000);
}

void test_065_performance_stress() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    uint32_t startTime = millis();
    
    // Stress test with many transitions
    for (int i = 0; i < 1000; i++) {
        if (sm->getCurrentStateId() == 1) {
            sm->processEvent(1);
        } else {
            sm->processEvent(2);
        }
    }
    
    uint32_t elapsed = millis() - startTime;
    
    // Should handle 1000 transitions efficiently
    TEST_ASSERT_TRUE(elapsed < 500); // Less than 500ms
    
    // Verify statistics are correct
    stateMachineStats stats = sm->getStatistics();
    TEST_ASSERT_TRUE(stats.totalTransitions >= 1000);
}

void test_066_scoreboard_concurrent_updates() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(1, 2, 3));
    sm->addTransition(stateTransition(1, 3, 4));
    
    // Test multiple rapid scoreboard updates
    for (int i = 0; i < 10; i++) {
        sm->setInitialState(1);
        sm->processEvent(1); // Updates scoreboard for state 1
        sm->setInitialState(1);
        sm->processEvent(2); // Updates scoreboard for state 1 again
        sm->setInitialState(1);
        sm->processEvent(3); // Updates scoreboard for state 1 again
    }
    
    // Scoreboard should reflect all updates
    uint32_t finalScore = sm->getScoreboard(1);
    TEST_ASSERT_TRUE(finalScore >= 30); // At least 30 updates
}

void test_067_statistics_boundary_values() {
    sm->setInitialState(0);
    sm->addTransition(stateTransition(0, 0, 1));
    sm->addTransition(stateTransition(1, 255, 254));
    sm->addTransition(stateTransition(254, 128, 255));
    
    // Test boundary event values
    sm->processEvent(0);    // Min event
    sm->processEvent(255);  // Max event  
    sm->processEvent(128);  // Mid event
    
    stateMachineStats stats = sm->getStatistics();
    TEST_ASSERT_EQUAL_UINT32(3, stats.totalTransitions);
    TEST_ASSERT_EQUAL_UINT32(3, stats.stateChanges);
}

void test_068_scoreboard_array_bounds() {
    // Test scoreboard with all valid indices
    for (int i = 0; i < 4; i++) {
        sm->setScoreboard(i * 100, i);
        TEST_ASSERT_EQUAL_UINT32(i * 100, sm->getScoreboard(i));
    }
    
    // Test that reading invalid indices doesn't crash
    uint32_t score = sm->getScoreboard(10); // Beyond array bounds
    TEST_ASSERT_TRUE(score == 0); // Should return 0 or handle gracefully
}

void test_069_statistics_timing_accuracy() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    stateMachineStats before = sm->getStatistics();
    uint32_t startTime = micros();
    
    sm->processEvent(1);
    
    uint32_t elapsed = micros() - startTime;
    stateMachineStats after = sm->getStatistics();
    
    // Verify timing statistics are reasonable
    TEST_ASSERT_TRUE(after.totalTransitions == before.totalTransitions + 1);
    TEST_ASSERT_TRUE(elapsed < 10000); // Should complete quickly
}

void test_070_scoreboard_incremental_updates() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    
    uint32_t initialScore = sm->getScoreboard(1);
    
    // Multiple transitions should increment scoreboard
    for (int i = 0; i < 5; i++) {
        sm->setInitialState(1);
        sm->processEvent(1);
    }
    
    uint32_t finalScore = sm->getScoreboard(1);
    TEST_ASSERT_TRUE(finalScore > initialScore + 4);
}

void test_071_statistics_overflow_protection() {
    // This test verifies that statistics don't overflow with extreme usage
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    // Simulate heavy usage
    for (int i = 0; i < 10000; i++) {
        if (sm->getCurrentStateId() == 1) {
            sm->processEvent(1);
        } else {
            sm->processEvent(2);
        }
    }
    
    stateMachineStats stats = sm->getStatistics();
    
    // Verify statistics are reasonable and didn't overflow
    TEST_ASSERT_TRUE(stats.totalTransitions >= 10000);
    TEST_ASSERT_TRUE(stats.stateChanges >= 10000);
    TEST_ASSERT_TRUE(stats.totalTransitions < 0xFFFFFFFF); // Not overflowed
}

void test_072_scoreboard_reset_behavior() {
    sm->setInitialState(1);
    sm->setScoreboard(500, 1);
    sm->setScoreboard(600, 2);
    
    TEST_ASSERT_EQUAL_UINT32(500, sm->getScoreboard(1));
    TEST_ASSERT_EQUAL_UINT32(600, sm->getScoreboard(2));
    
    // Reset scoreboard
    sm->setScoreboard(0, 1);
    sm->setScoreboard(0, 2);
    
    TEST_ASSERT_EQUAL_UINT32(0, sm->getScoreboard(1));
    TEST_ASSERT_EQUAL_UINT32(0, sm->getScoreboard(2));
}

void test_073_comprehensive_statistics_validation() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 3));
    sm->addTransition(stateTransition(3, 3, 1));
    
    stateMachineStats initial = sm->getStatistics();
    
    // Complete cycle
    sm->processEvent(1); // 1->2
    sm->processEvent(2); // 2->3
    sm->processEvent(3); // 3->1
    
    // Try invalid transition
    sm->processEvent(99);
    
    stateMachineStats final = sm->getStatistics();
    
    // Verify all statistics
    TEST_ASSERT_EQUAL_UINT32(initial.totalTransitions + 4, final.totalTransitions);
    TEST_ASSERT_EQUAL_UINT32(initial.stateChanges + 3, final.stateChanges);
    TEST_ASSERT_EQUAL_UINT32(initial.failedTransitions + 1, final.failedTransitions);
    TEST_ASSERT_EQUAL_UINT32(initial.actionExecutions + 3, final.actionExecutions);
}

void test_074_scoreboard_multi_instance() {
    // Test that different state machine instances have independent scoreboards
    ImprovedStateMachine* sm2 = new ImprovedStateMachine();
    
    sm->setScoreboard(100, 1);
    sm2->setScoreboard(200, 1);
    
    TEST_ASSERT_EQUAL_UINT32(100, sm->getScoreboard(1));
    TEST_ASSERT_EQUAL_UINT32(200, sm2->getScoreboard(1));
    
    delete sm2;
}

void test_075_statistics_and_scoreboard_integration() {
    sm->setInitialState(1);
    sm->addTransition(stateTransition(1, 1, 2));
    sm->addTransition(stateTransition(2, 2, 1));
    
    // Set initial scoreboard values
    sm->setScoreboard(1000, 1);
    sm->setScoreboard(2000, 2);
    
    stateMachineStats before = sm->getStatistics();
    uint32_t score1_before = sm->getScoreboard(1);
    uint32_t score2_before = sm->getScoreboard(2);
    
    // Process events
    sm->processEvent(1); // 1->2
    sm->processEvent(2); // 2->1
    
    stateMachineStats after = sm->getStatistics();
    uint32_t score1_after = sm->getScoreboard(1);
    uint32_t score2_after = sm->getScoreboard(2);
    
    // Verify both statistics and scoreboards updated
    TEST_ASSERT_EQUAL_UINT32(before.totalTransitions + 2, after.totalTransitions);
    TEST_ASSERT_TRUE(score1_after > score1_before);
    TEST_ASSERT_TRUE(score2_after > score2_before);
}

// Unity test registration
void setup() {
    UNITY_BEGIN();
    
#ifdef ARDUINO
    Serial.println("=== STATISTICS & SCOREBOARD TEST SUITE (25 tests) ===");
#endif
    
    RUN_TEST(test_051_statistics_tracking);
    RUN_TEST(test_052_failed_transition_statistics);
    RUN_TEST(test_053_action_execution_stats);
    RUN_TEST(test_054_statistics_accumulation);
    RUN_TEST(test_055_scoreboard_functionality);
    RUN_TEST(test_056_scoreboard_updates);
    RUN_TEST(test_057_scoreboard_boundaries);
    RUN_TEST(test_058_multi_state_scoreboard);
    RUN_TEST(test_059_scoreboard_overflow_protection);
    RUN_TEST(test_060_performance_timing);
    RUN_TEST(test_061_statistics_consistency);
    RUN_TEST(test_062_scoreboard_state_correlation);
    RUN_TEST(test_063_statistics_error_tracking);
    RUN_TEST(test_064_scoreboard_persistence);
    RUN_TEST(test_065_performance_stress);
    RUN_TEST(test_066_scoreboard_concurrent_updates);
    RUN_TEST(test_067_statistics_boundary_values);
    RUN_TEST(test_068_scoreboard_array_bounds);
    RUN_TEST(test_069_statistics_timing_accuracy);
    RUN_TEST(test_070_scoreboard_incremental_updates);
    RUN_TEST(test_071_statistics_overflow_protection);
    RUN_TEST(test_072_scoreboard_reset_behavior);
    RUN_TEST(test_073_comprehensive_statistics_validation);
    RUN_TEST(test_074_scoreboard_multi_instance);
    RUN_TEST(test_075_statistics_and_scoreboard_integration);
    
#ifdef ARDUINO
    Serial.println("=== STATISTICS & SCOREBOARD TESTS COMPLETED ===");
#endif
    
    UNITY_END();
}

void loop() {
    // Required for Arduino, but not used in this test
}
